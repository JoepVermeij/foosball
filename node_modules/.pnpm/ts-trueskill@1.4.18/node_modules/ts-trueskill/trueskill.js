"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gaussian = require("gaussian");
var _ = require("lodash");
var math = require("mathjs");
var factorgraph_1 = require("./factorgraph");
var quality_helper_1 = require("./quality-helper");
var rating_1 = require("./rating");
/** Default initial mean of ratings. */
var MU = 25;
/** Default initial standard deviation of ratings. */
var SIGMA = MU / 3;
/** Default distance that guarantees about 76% chance of winning. */
var BETA = SIGMA / 2;
/** Default dynamic factor. */
var TAU = SIGMA / 100;
/** Default draw probability of the game. */
var DRAW_PROBABILITY = 0.10;
/** A basis to check reliability of the result. */
var DELTA = 0.0001;
/** reuseable gaussian */
var gaus = gaussian(0, 1);
/**
 * Calculates a draw-margin from the given drawProbability
 */
function calcDrawMargin(drawProbability, size, env) {
    if (!env) {
        env = global_env();
    }
    return gaus.ppf((drawProbability + 1) / 2) * Math.sqrt(size) * env.beta;
}
exports.calcDrawMargin = calcDrawMargin;
/**
 * Makes a size map of each teams.
 */
function _teamSizes(ratingGroups) {
    var teamSizes = [0];
    ratingGroups.map(function (group) { return teamSizes.push(group.length + teamSizes[teamSizes.length - 1]); });
    teamSizes.shift();
    return teamSizes;
}
/**
 * Implements a TrueSkill environment.  An environment could have
 * customized constants.  Every games have not same design and may need to
 * customize TrueSkill constants.
 *
 * For example, 60% of matches in your game have finished as draw then you
 * should set ``draw_probability`` to 0.60::
 *
 * const env = new TrueSkill(draw_probability=0.60)
 *
 * For more details of the constants, see `The Math Behind TrueSkill`_ by
 * Jeff Moser.
 *
 */
var TrueSkill = /** @class */ (function () {
    function TrueSkill(mu, sigma, beta, tau, drawProbability) {
        this.mu = mu || MU;
        this.sigma = sigma || SIGMA;
        this.beta = beta || BETA;
        this.tau = tau || TAU;
        this.drawProbability = (drawProbability === undefined || drawProbability === null) ?
            DRAW_PROBABILITY : drawProbability;
    }
    /** Recalculates ratings by the ranking table */
    TrueSkill.prototype.rate = function (ratingGroups, ranks, weights, minDelta) {
        if (ranks === void 0) { ranks = null; }
        if (weights === void 0) { weights = null; }
        if (minDelta === void 0) { minDelta = DELTA; }
        var _a = this.validateRatingGroups(ratingGroups), newRatingGroups = _a[0], keys = _a[1];
        weights = this.validate_weights(newRatingGroups, weights);
        var groupSize = ratingGroups.length;
        if (ranks && ranks.length !== groupSize) {
            throw new Error('Wrong ranks');
        }
        var newRanks = ranks ? ranks : Array.from({ length: groupSize }, function (z, i) { return i; });
        // sort rating groups by rank
        var zip = [];
        for (var idx = 0; idx < newRatingGroups.length; idx++) {
            zip.push([newRatingGroups[idx], newRanks[idx], weights[idx]]);
        }
        var position = 0;
        var positions = zip.map(function (el) {
            var res = [position, el];
            position++;
            return res;
        });
        var sorting = _.orderBy(positions, function (x) { return x[1][1]; });
        var sortedRatingGroups = [];
        var sortedRanks = [];
        var sortedWeights = [];
        // tslint:disable-next-line:no-unused-variable
        for (var _i = 0, sorting_1 = sorting; _i < sorting_1.length; _i++) {
            var _b = sorting_1[_i], x = _b[0], _c = _b[1], g = _c[0], r = _c[1], w = _c[2];
            sortedRatingGroups.push(g);
            sortedRanks.push(r);
            // make weights to be greater than 0
            var max = w.map(function (ww) { return Math.max(minDelta, ww); });
            sortedWeights.push(max);
        }
        // build factor graph
        var flattenRatings = _.flatten(sortedRatingGroups);
        var flattenWeights = _.flatten(sortedWeights);
        var size = flattenRatings.length;
        // create variables
        var fill = Array.from({ length: size }, function (z, i) { return i; });
        var ratingVars = fill.map(function () { return new factorgraph_1.Variable(); });
        var perfVars = fill.map(function () { return new factorgraph_1.Variable(); });
        var teamPerfVars = Array.from({ length: groupSize }, function (z, i) { return i; })
            .map(function () { return new factorgraph_1.Variable(); });
        var teamDiffVars = Array.from({ length: groupSize - 1 }, function (z, i) { return i; })
            .map(function () { return new factorgraph_1.Variable(); });
        var teamSizes = _teamSizes(sortedRatingGroups);
        // layer builders
        var layers = this.runSchedule(ratingVars, flattenRatings, perfVars, teamPerfVars, teamSizes, flattenWeights, teamDiffVars, sortedRanks, sortedRatingGroups, minDelta);
        var transformedGroups = [];
        var trimmed = [0].concat(teamSizes.slice(0, teamSizes.length - 1));
        for (var idx = 0; idx < teamSizes.length; idx++) {
            var group = layers
                .slice(trimmed[idx], teamSizes[idx])
                .map(function (f) { return new rating_1.Rating(f.v.mu, f.v.sigma); });
            transformedGroups.push(group);
        }
        var pulledTranformedGroups = [];
        for (var idx = 0; idx < sorting.length; idx++) {
            pulledTranformedGroups.push([sorting[idx][0], transformedGroups[idx]]);
        }
        var unsorting = pulledTranformedGroups.sort(function (a, b) { return a[0] - b[0]; });
        if (!keys) {
            return unsorting.map(function (k) { return k[1]; });
        }
        return unsorting.map(function (v) {
            return _.zipObject(keys[v[0]], v[1]);
        });
    };
    /**
     * Calculates the match quality of the given rating groups. Result
     * is the draw probability in the association::
     *
     *   env = TrueSkill()
     *   if env.quality([team1, team2, team3]) < 0.50 {
     *     console.log('This match seems to be not so fair')
     *   }
     */
    TrueSkill.prototype.quality = function (ratingGroups, weights) {
        var _this = this;
        var _a = this.validateRatingGroups(ratingGroups), newRatingGroups = _a[0], keys = _a[1];
        var newWeights = this.validate_weights(ratingGroups, weights, keys);
        var flattenRatings = _.flatten(ratingGroups);
        var flattenWeights = _.flatten(newWeights);
        var length = flattenRatings.length;
        // a vector of all of the skill means
        var meanMatrix = math.matrix(flattenRatings.map(function (r) { return [r.mu]; }));
        var varianceMatrix = quality_helper_1.VarianceMatrix(flattenRatings, length, length);
        var rotatedAMatrix = quality_helper_1.RotatedAMatrix(newRatingGroups, flattenWeights);
        var aMatrix = math.transpose(rotatedAMatrix);
        // match quality further derivation
        var modifiedRotatedAMatrix = rotatedAMatrix
            .map(function (value, index, matrix) { return Math.pow(_this.beta, 2) * value; });
        var start = math.multiply(math.transpose(meanMatrix), aMatrix);
        var ata = math.multiply(modifiedRotatedAMatrix, aMatrix);
        var atsa = math.multiply(rotatedAMatrix, math.multiply(varianceMatrix, aMatrix));
        var middle = math.add(ata, atsa);
        var end = math.multiply(rotatedAMatrix, meanMatrix);
        // make result
        var eArg = math.det(math.multiply(math.multiply([[-0.5]], math.multiply(start, math.inv(middle))), end));
        var sArg = math.det(ata) / math.det(middle);
        return math.exp(eArg) * math.sqrt(sArg);
    };
    /**
     * Initializes new `Rating` object, but it fixes default mu and
     * sigma to the environment's.
     * var env = TrueSkill(mu=0, sigma=1)
     * var env.createRating()
     * trueskill.Rating(mu=0.000, sigma=1.000)
     */
    TrueSkill.prototype.createRating = function (mu, sigma) {
        if (mu === void 0) { mu = this.mu; }
        if (sigma === void 0) { sigma = this.sigma; }
        return new rating_1.Rating(mu, sigma);
    };
    /**
     * Returns the value of the rating exposure.  It starts from 0 and
     * converges to the mean.  Use this as a sort key in a leaderboard
     */
    TrueSkill.prototype.expose = function (rating) {
        var k = this.mu / this.sigma;
        return rating.mu - k * rating.sigma;
    };
    /**
     * Registers the environment as the global environment.
     */
    TrueSkill.prototype.make_as_global = function () {
        return setup(undefined, undefined, undefined, undefined, undefined, this);
    };
    /**
     * Taken from https://github.com/sublee/trueskill/issues/1
     */
    TrueSkill.prototype.winProbability = function (a, b) {
        var deltaMu = _.sumBy(a, 'mu') - _.sumBy(b, _.identity('mu'));
        var sumSigma = _.sum(a.map(function (x) { return Math.pow(x.sigma, 2); })) + _.sum(b.map(function (x) { return Math.pow(x.sigma, 2); }));
        var playerCount = a.length + b.length;
        var denominator = Math.sqrt(playerCount * (BETA * BETA) + sumSigma);
        return gaus.cdf(deltaMu / denominator);
    };
    /**
     * The non-draw version of "V" function.
     * "V" calculates a variation of a mean.
     */
    TrueSkill.prototype.v_win = function (diff, drawMargin) {
        var x = diff - drawMargin;
        var denom = gaus.cdf(x);
        return denom ? (gaus.pdf(x) / denom) : -x;
    };
    TrueSkill.prototype.v_draw = function (diff, drawMargin) {
        var absDiff = Math.abs(diff);
        var _a = [drawMargin - absDiff, -drawMargin - absDiff], a = _a[0], b = _a[1];
        var denom = gaus.cdf(a) - gaus.cdf(b);
        var numer = gaus.pdf(b) - gaus.pdf(a);
        return (denom ? (numer / denom) : a) * (diff < 0 ? -1 : +1);
    };
    /**
     * The non-draw version of "W" function.
     * "W" calculates a variation of a standard deviation.
     */
    TrueSkill.prototype.w_win = function (diff, drawMargin) {
        var x = diff - drawMargin;
        var v = this.v_win(diff, drawMargin);
        var w = v * (v + x);
        if (0 < w && w < 1) {
            return w;
        }
        throw new Error('floating point error');
    };
    /** The draw version of "W" function. */
    TrueSkill.prototype.w_draw = function (diff, drawMargin) {
        var absDiff = Math.abs(diff);
        var a = drawMargin - absDiff;
        var b = -drawMargin - absDiff;
        var denom = gaus.cdf(a) - gaus.cdf(b);
        if (!denom) {
            throw new Error('Floating point error');
        }
        var v = this.v_draw(absDiff, drawMargin);
        return (Math.pow(v, 2)) + (a * gaus.pdf(a) - b * gaus.pdf(b)) / denom;
    };
    /**
     * Validates a ratingGroups argument. It should contain more than
     * 2 groups and all groups must not be empty.
     */
    TrueSkill.prototype.validateRatingGroups = function (ratingGroups) {
        if (ratingGroups.length < 2) {
            throw new Error('Need multiple rating groups');
        }
        for (var _i = 0, ratingGroups_1 = ratingGroups; _i < ratingGroups_1.length; _i++) {
            var group = ratingGroups_1[_i];
            if (group.length === 0) {
                throw new Error('Each group must contain multiple ratings');
            }
            if (group instanceof rating_1.Rating) {
                throw new Error('Rating cannot be a rating group');
            }
        }
        if (!Array.isArray(ratingGroups[0])) {
            var keys = [];
            var newRatingGroups = [];
            var _loop_1 = function (dictRatingGroup) {
                var ratingGroup = [];
                var keyGroup = [];
                _.forEach(dictRatingGroup, function (rating, key) {
                    ratingGroup.push(rating);
                    keyGroup.push(key);
                });
                newRatingGroups.push(ratingGroup);
                keys.push(keyGroup);
            };
            for (var _a = 0, ratingGroups_2 = ratingGroups; _a < ratingGroups_2.length; _a++) {
                var dictRatingGroup = ratingGroups_2[_a];
                _loop_1(dictRatingGroup);
            }
            return [newRatingGroups, keys];
        }
        return [ratingGroups, null];
    };
    TrueSkill.prototype.validate_weights = function (ratingGroups, weights, keys) {
        if (!weights) {
            return ratingGroups
                .map(function (n) { return Array(n.length).fill(1); });
        }
        // TODO: weights is dict?
        return weights;
    };
    TrueSkill.prototype.buildRatingLayer = function (ratingVars, flattenRatings) {
        var t = this.tau;
        return ratingVars.map(function (n, idx) { return new factorgraph_1.PriorFactor(n, flattenRatings[idx], t); });
    };
    TrueSkill.prototype.buildPerfLayer = function (ratingVars, perfVars) {
        var b = Math.pow(this.beta, 2);
        return ratingVars.map(function (n, idx) { return new factorgraph_1.LikelihoodFactor(n, perfVars[idx], b); });
    };
    TrueSkill.prototype.buildTeamPerfLayer = function (teamPerfVars, perfVars, teamSizes, flattenWeights) {
        var team = 0;
        return teamPerfVars.map(function (teamPerfVar) {
            var start = team > 0 ? teamSizes[team - 1] : 0;
            var end = teamSizes[team];
            team = team + 1;
            return new factorgraph_1.SumFactor(teamPerfVar, perfVars.slice(start, end), flattenWeights.slice(start, end));
        });
    };
    TrueSkill.prototype.buildTeamDiffLayer = function (teamPerfVars, teamDiffVars) {
        var team = 0;
        return teamDiffVars.map(function (teamDiffVar) {
            var sl = teamPerfVars.slice(team, team + 2);
            team++;
            return new factorgraph_1.SumFactor(teamDiffVar, sl, [1, -1]);
        });
    };
    TrueSkill.prototype.buildTruncLayer = function (teamDiffVars, sortedRanks, sortedRatingGroups) {
        var _this = this;
        var x = 0;
        return teamDiffVars.map(function (teamDiffVar) {
            // static draw probability
            var drawProbability = _this.drawProbability;
            var lengths = sortedRatingGroups.slice(x, x + 2).map(function (n) { return n.length; });
            var drawMargin = calcDrawMargin(drawProbability, _.sum(lengths), _this);
            var vFunc = function (a, b) { return _this.v_win(a, b); };
            var wFunc = function (a, b) { return _this.w_win(a, b); };
            if (sortedRanks[x] === sortedRanks[x + 1]) {
                vFunc = function (a, b) { return _this.v_draw(a, b); };
                wFunc = function (a, b) { return _this.w_draw(a, b); };
            }
            x++;
            return new factorgraph_1.TruncateFactor(teamDiffVar, vFunc, wFunc, drawMargin);
        });
    };
    /**
     * Sends messages within every nodes of the factor graph
     * until the result is reliable.
     */
    TrueSkill.prototype.runSchedule = function (ratingVars, flattenRatings, perfVars, teamPerfVars, teamSizes, flattenWeights, teamDiffVars, sortedRanks, sortedRatingGroups, minDelta) {
        if (minDelta === void 0) { minDelta = DELTA; }
        if (minDelta <= 0) {
            throw new Error('minDelta must be greater than 0');
        }
        var ratingLayer = this.buildRatingLayer(ratingVars, flattenRatings);
        var perfLayer = this.buildPerfLayer(ratingVars, perfVars);
        var teamPerfLayer = this.buildTeamPerfLayer(teamPerfVars, perfVars, teamSizes, flattenWeights);
        ratingLayer.map(function (f) { return f.down(); });
        perfLayer.map(function (f) { return f.down(); });
        teamPerfLayer.map(function (f) { return f.down(); });
        // arrow #1, #2, #3
        var teamDiffLayer = this.buildTeamDiffLayer(teamPerfVars, teamDiffVars);
        var truncLayer = this.buildTruncLayer(teamDiffVars, sortedRanks, sortedRatingGroups);
        var teamDiffLen = teamDiffLayer.length;
        for (var index = 0; index <= 10; index++) {
            var delta = 0;
            if (teamDiffLen === 1) {
                // only two teams
                teamDiffLayer[0].down();
                delta = truncLayer[0].up();
            }
            else {
                // multiple teams
                delta = 0;
                for (var z = 0; z < teamDiffLen - 1; z++) {
                    teamDiffLayer[z].down();
                    delta = Math.max(delta, truncLayer[z].up());
                    teamDiffLayer[z].up(1);
                }
                for (var z = teamDiffLen - 1; z > 0; z--) {
                    teamDiffLayer[z].down();
                    delta = Math.max(delta, truncLayer[z].up());
                    teamDiffLayer[z].up(0);
                }
            }
            // repeat until too small update
            if (delta <= minDelta) {
                break;
            }
        }
        // up both ends
        teamDiffLayer[0].up(0);
        teamDiffLayer[teamDiffLen - 1].up(1);
        // up the remainder of the black arrows
        for (var _i = 0, teamPerfLayer_1 = teamPerfLayer; _i < teamPerfLayer_1.length; _i++) {
            var f = teamPerfLayer_1[_i];
            for (var x = 0; x < f.vars.length - 1; x++) {
                f.up(x);
            }
        }
        for (var _a = 0, perfLayer_1 = perfLayer; _a < perfLayer_1.length; _a++) {
            var f = perfLayer_1[_a];
            f.up();
        }
        return ratingLayer;
    };
    return TrueSkill;
}());
exports.TrueSkill = TrueSkill;
/**
 * A shortcut to rate just 2 players in a head-to-head match
 */
function rate_1vs1(rating1, rating2, drawn, minDelta, env) {
    if (drawn === void 0) { drawn = false; }
    if (minDelta === void 0) { minDelta = DELTA; }
    if (!env) {
        env = global_env();
    }
    var ranks = [0, drawn ? 0 : 1];
    var teams = env.rate([[rating1], [rating2]], ranks, undefined, minDelta);
    return [teams[0][0], teams[1][0]];
}
exports.rate_1vs1 = rate_1vs1;
/**
 * A shortcut to calculate the match quality between 2 players in
 * a head-to-head match
 */
function quality_1vs1(rating1, rating2, env) {
    if (!env) {
        env = global_env();
    }
    return env.quality([[rating1], [rating2]]);
}
exports.quality_1vs1 = quality_1vs1;
/**
 * Gets the `TrueSkill` object which is the global environment.
 */
function global_env() {
    if (exports.trueskill) {
        return exports.trueskill;
    }
    setup();
    return exports.trueskill;
}
exports.global_env = global_env;
/**
 * Setup the global environment defaults
 */
function setup(mu, sigma, beta, tau, drawProbability, env) {
    if (mu === void 0) { mu = MU; }
    if (sigma === void 0) { sigma = SIGMA; }
    if (beta === void 0) { beta = BETA; }
    if (tau === void 0) { tau = TAU; }
    if (drawProbability === void 0) { drawProbability = DRAW_PROBABILITY; }
    if (!env) {
        env = new TrueSkill(mu, sigma, beta, tau, drawProbability);
    }
    exports.trueskill = env;
    return env;
}
exports.setup = setup;
/**
 * A proxy function for `TrueSkill.rate` of the global environment.
 */
function rate(ratingGroups, ranks, weights, minDelta) {
    if (minDelta === void 0) { minDelta = DELTA; }
    return global_env().rate(ratingGroups, ranks, weights, minDelta);
}
exports.rate = rate;
function winProbability(a, b) {
    return global_env().winProbability(a, b);
}
exports.winProbability = winProbability;
/**
 * A proxy function for `TrueSkill.quality` of the global
 * environment.
 */
function quality(ratingGroups, weights) {
    return global_env().quality(ratingGroups, weights);
}
exports.quality = quality;
/**
 * A proxy function for TrueSkill.expose of the global environment.
 */
function expose(rating) {
    return global_env().expose(rating);
}
exports.expose = expose;
//# sourceMappingURL=trueskill.js.map